### Decorator 패턴에 적합한 객체지향 프로그래밍 개념은 무엇인가요?
기존의 클래스를 수정하지 않고도 새로운 기능을 제공합니다. 이는 객체지향 프로그래밍 개념의 구성에 해당합니다.

### Singleton 패턴은 언제 사용하는가?
클래스의 애플리케이션 레벨(전역) 인스턴스가 하나만 필요할 때 사용하면 적합합니다. 단, 싱글턴은 클래스간 결합을
증가시키고 개발, 테스트 및 디버깅 중에 `병목 현상`을 발생시킬 수 있으므로 주의해서 사용해야 합니다. `이펙티브 자바 3판`에서 언급했듯이
자바 열거형 `enum`을 사용하는 것이 이 패턴을 구현하는 가장 좋은 방법입니다.

#### Singleton 패턴을 사용하는 일반적인 시나리오
`logger`, `java.lang Runtime` 과 같은 전역 환경 설정, 하드웨어 접근, 데이터베이스 연결

### strategy 패턴과 state 패턴의 차이점은 무엇인가?
`state` 디자인 패턴은 상태에 따라 특정 작업을 수행하도록 설계되었습니다. 이 패턴은 클래스를 변경하지 않는 환경에서 서로 다른 상태의
특정 동작을 나타냅니다. 
`strategy` 디자인 패턴은 코드를 수정하지 않고 여러 알고리즘을 전환하여 사용하기 위한 패턴이빈다. 클라이언트는 구성과 런타임 위임 `delegation`을 통해
알고리즘을 전환합니다. 또한 상태 패턴에서는 각 상태를 다른 상태로 연결하며 흐름이 생성되기 때문에 상태 전이 순서가 명확하지만, 전략 패턴에서는 클라이언트가
원하는 알고리즘을 순서와 상관없이 선택할 수 있습니다.

### proxy 패턴과 decorator 패턴의 차이점은 무엇인가?
`proxy` 디자인 패턴은 무언가에 대한 접근 제어 게이트웨이를 제공하는데 유용합니다. 실제 객체를 대신할 대리 객체를 생성합니다. 실제 객체에 대한
각 요청은 대리 객체를 통과해야 하며, 대리 객체는 이를 실제 객체로 전달할 방법과 시점을 결정합니다. 

`decorator` 디자인 패턴은 객체를 생성하지 않으며 런타임에 기존 객체를 새로운 기능으로 장식할 뿐입니다.

### `facade` 퍼사드 패턴과 Decorator 패턴의 차이점은 무엇인가?
`Decorator` 디자인 패턴은 객체에 새로운 기능을 추가하거나 객체를 장식한다는 의미이지만, `facade` 디자인 패턴은 객체에 새로운 기능을 전혀 추가 하지 않습니다.
시스템의 복잡성을 숨기고 기존 기능만 표면에 내세워 클라이언트에게 노출되는 친근한 얼굴 뒤에서 기능을 호출합니다. 복잡한 작업을 수행하기 위해 개별 구성요소를
호출하는 간단한 인터페이스를 노출할 수 있습니다.

예를 들어 `Decorator` 패턴은 엔진, 기어박스 등으로 뼈대를 장식하여 자동차를 만드는데 사용할 수 있고, `facade` 패턴은 자동차 생성과정의 세부 사항을 아는 산업용 로봇에
명령을 내릴 수 있는 간단한 인터페이스를 노출하여 자동차를 만드는 복잡성을 숨길 수 있습니다.

### Template method 패턴과 strategy 패턴의 주요 차이점은 무엇인가?
`template method` 패턴과 `strategy` 패턴은 도메인별 알고리즘 집합을 객체로 캡슐화하지만 동일한 방법을 사용하지는 않습니다. 주요 차이점은
`starategy` 패턴은 요구사항을 기반으로 서로 다른 전략 또는 알고리즘 중에 사용할 알고리즘을 런타임에 결정하지만, `template method` 패턴은 고정된 뼈대, 
즉, 사전에 정의된 일련의 단계에 따라 구현된 알고리즘대로 동작한다는 사실입니다.

`startegy` 패턴은 신용카드 또는 페이팔과 같은 서로 다른 지불 전략 사이에서 어떤 전략을 사용할지 결정하는거라면   
`template method` 패턴은 특정 전략으로 지불하기 위해 사전에 정의된 단계의 순서를 설명할 수 있습니다. 예를 들어 페이팔로 지불하려면 고정된 일련의 단계가 필요합니다.

### Builder 패턴과 Factory 패턴의 주요 차이점은 무엇인가?
`factory` 패턴은 단일 메서드 호출로 객체를 생성합니다. 이때 필요한 모든 매개변수를 전달해야 하며 팩토리는 일반적으로 생성자를 호출하여 객체를 반환할 것입니다.   
`builder` 패턴은 매개변수의 조합을 형성할 수 있는 setter 메서드의 연쇄작용을 통해 복잡한 객체를 구성할 수 있도록 설계되었습니다. 연쇄작용 끝에서 매개변수 목록이
설정되었음을 알리는 build 메서드를 노출하며 이 시점에 객체를 구축할 수 있습니다.

즉, `factory` 패턴은 생성자의 래퍼 `wrapper` 역할을 하는 반면, `builder` 패턴은 세분화 되어 생성자에게 전달할 수 있는 모든 매개변수의 래퍼 역할을 합니다.

### Adapter 패턴과 bridge 패턴의 주요 차이점은 무엇인가?
`adapter` 패턴은 타사 코드와 같이 수정할수 없는 기존 코드와 새로운 시스템 또는 인터페이스 사이의 호환성을 제공하려고 노력합니다.      
`bridge` 패턴은 사전에 구현되며 엄청난 수의 클래스 작성을 피하고자 구현에서 추상화를 분리하는 것을 의미합니다.

따라서 `adapter` 패턴은 설계 후에 각 항목 사이의 호환성을 제공하고자 노력하고, `bridge` 패턴은 추상화와 구현이 독립적으로 변경될 수 있도록
사전 구축됩니다. 

### ※ `adapter`의 첫글자 `a`를 `after` 로 `bridge` 패턴의 `b`를 `before` 로 생각하면 기억하기 쉽다.

`adapter` 패턴은 독립적으로 작동하지만, 호환이 되는 입력 및 출력값이 없어 서로 소통할 수 없는 두 시스템 사이에서 `중간자` 역할을 합니다.   
`bridge` 패턴은 직교하는 클래스 계층을 통해 문제를 해결할수 있지만, 확장성 문제와 제한된 확장으로 인해 어려움을 겪습니다.
























